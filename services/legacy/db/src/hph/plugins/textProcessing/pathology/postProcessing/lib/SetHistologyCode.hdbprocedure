procedure "hc.hph.plugins.textProcessing.pathology.postProcessing.lib::SetHistologyCode"(
    in iv_config_id   nvarchar(1024),
    in iv_ta_batch_id nvarchar(1024)
)
  language sqlscript
  sql security definer as
begin

	declare lv_ambig        nvarchar(100) := 'Ambiguous';
	declare lv_hist_parent  nvarchar(100) := 'med_CancerHistology';
	declare lv_ca_hist_rule    nvarchar(100) := 'CancerHistology';
	declare lv_ca_icdo_rule    nvarchar(100) := 'CancerICDO';
	declare lv_hist_dict    nvarchar(100) := 'med_HISTO/ICDO3';
	
	
	-- prepare candidates from TA_EXT
	lt_cand_tmp =
		select
			"CONFIG_ID",
			"BATCH_ID",
			dense_rank() over (
				partition by
					"DummyPartition"
				order by
					"RuleID"
			) as "CandidateID", 
			"DWID",
			"TA_COUNTER",
			"TA_TOKEN",
			"TA_TYPE",
			"TA_NORMALIZED",
			"TA_OFFSET",
			"TA_PARENT"
		from (
			select
				0 as "DummyPartition",
				rule."DWID"||':'||rule."TA_COUNTER" as "RuleID",
				idx."CONFIG_ID",
				idx."BATCH_ID",
				idx."DWID",
				idx."TA_COUNTER",
				idx."TA_TOKEN",
				idx."TA_TYPE",
				idx."TA_NORMALIZED",
				idx."TA_OFFSET",
				idx."TA_PARENT"
			from       "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" idx
			inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" rule
			on  rule."DWID"       = idx."DWID"
			and rule."TA_COUNTER" = idx."TA_PARENT"
			and rule."TA_TYPE"    = :lv_hist_parent
			and rule."CONFIG_ID"  = :iv_config_id
			and rule."BATCH_ID"   = :iv_ta_batch_id
			and idx."CONFIG_ID"   = :iv_config_id
			and idx."BATCH_ID"    = :iv_ta_batch_id

			union

			select
				0 as "DummyPartition",
				rule."DWID"||':'||rule."TA_COUNTER" as "RuleID",
				idx."CONFIG_ID",
				idx."BATCH_ID",
				idx."DWID",
				idx."TA_COUNTER",
				idx."TA_TOKEN",
				idx."TA_TYPE",
				idx."TA_NORMALIZED",
				idx."TA_OFFSET",
				rule."TA_COUNTER" as "TA_PARENT"
			from       "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" idx
			inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" rule
			on  rule."CONFIG_ID"  = :iv_config_id
			and rule."BATCH_ID"   = :iv_ta_batch_id
			and idx."CONFIG_ID"   = :iv_config_id
			and idx."BATCH_ID"    = :iv_ta_batch_id
			and rule."DWID"       = idx."DWID"
			and rule."TA_TYPE"    = :lv_hist_parent
			and idx."TA_PARENT" is null
			and idx."TA_TYPE"    <> :lv_hist_parent
			and (idx."TA_OFFSET" >= rule."TA_OFFSET") 
			and (idx."TA_OFFSET" <= (rule."TA_OFFSET" + length(rule."TA_TOKEN")))
		)
	;
	
	-----------------------------------------------------------------------------------------------
	-- eliminate duplicate tokens while keeping distinct ta_normalized values
	lt_dist_cand =
		select distinct
			t_tok."CONFIG_ID",
			t_tok."BATCH_ID",
			t_tok."CandidateID",
			t_tok."TA_TOKEN",
			case when t_norm."TA_NORMALIZED" is not null
				then t_norm."TA_NORMALIZED"
				else null
			end as "TA_NORMALIZED",
			t_tok."TA_OFFSET"
		from :lt_cand_tmp            t_tok
		left outer join :lt_cand_tmp t_norm
		on  t_tok."CONFIG_ID"   = t_norm."CONFIG_ID"
		and t_tok."BATCH_ID"    = t_norm."BATCH_ID"
		and t_tok."CandidateID" = t_norm."CandidateID"
		and t_tok."TA_TOKEN"    = t_norm."TA_TOKEN"
		and t_tok."TA_OFFSET"   = t_norm."TA_OFFSET"
		and t_norm."TA_NORMALIZED" is not null
	;
	
	lt_cand_tmp =
		select
			t_cand_tmp.*
		from       :lt_cand_tmp  t_cand_tmp
		inner join :lt_dist_cand t_dist_cand
		on  t_dist_cand."CONFIG_ID"   = t_cand_tmp."CONFIG_ID"
		and t_dist_cand."BATCH_ID"    = t_cand_tmp."BATCH_ID"
		and t_dist_cand."CandidateID" = t_cand_tmp."CandidateID"
		and t_dist_cand."TA_TOKEN"    = t_cand_tmp."TA_TOKEN"
		and t_dist_cand."TA_OFFSET"   = t_cand_tmp."TA_OFFSET"
		and (
			   ( t_dist_cand."TA_NORMALIZED" is null and t_cand_tmp."TA_NORMALIZED" is null )
			or ( t_dist_cand."TA_NORMALIZED" = t_cand_tmp."TA_NORMALIZED" )
		)
	;
	--
	-----------------------------------------------------------------------------------------------

	-- isolate candidates for AM call
	lt_cand =
		select distinct
			t_cand."CandidateID",
			t_cand."TA_COUNTER"  as "ComponentID",
			t_cand."TA_TOKEN"    as "ComponentTermText",
			t_map."VocabularyID",
			t_map."Code"
		from :lt_cand_tmp t_cand
		left outer join "hc.hph.ta::Entities.ConceptMappings" t_map
		on  t_cand."TA_NORMALIZED" is not null
		and t_cand."TA_NORMALIZED" = t_map."TA_Concept"
	;

	lt_cand =
		select 
			"CandidateID",
			min("ComponentID") "ComponentID",
			"ComponentTermText",
			max("VocabularyID") "VocabularyID",
			max("Code") "Code"
 		from :lt_cand
		group by 
			"CandidateID",
			"ComponentTermText"
		;

	-- AM call
	call "hc.hph.ots.am.lib::MatchCandidates"(
		:iv_config_id,
		:lt_cand,
		lt_matches
	);
	
	-- ambiguous candidates (more than one code assigned)
	lt_ambig_cand =
		select
			"CandidateID"
		from :lt_matches
		group by
			"CandidateID"
		having count(distinct "Code") > 1
	;

	-- prepare output to be merged back to t_ta_temp
	lt_merge_output =
		select distinct
			t_cand_tmp."CONFIG_ID",
			t_cand_tmp."BATCH_ID",
			t_cand_tmp."DWID",
			t_cand_tmp."TA_PARENT",
			t_map."TA_Concept" as "TA_NORMALIZED"
		from       :lt_matches  t_mat
		inner join :lt_cand_tmp t_cand_tmp
		on  t_cand_tmp."CandidateID" = t_mat."CandidateID"
		and t_cand_tmp."TA_COUNTER"  = t_mat."ComponentID"
		inner join "hc.hph.ta::Entities.ConceptMappings" t_map
		on  t_map."VocabularyID" = t_mat."VocabularyID"
		and t_map."Code"         = t_mat."Code"
		-- exclude ambiguous matches
		left outer join :lt_ambig_cand t_ambig_cand
		on t_ambig_cand."CandidateID" = t_mat."CandidateID"
		where t_ambig_cand."CandidateID" is null
	;
    
	-- update normalized column in t_ta_temp 
	update "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_tmp
	set t_ta_tmp."TA_NORMALIZED" = t_merge_output."TA_NORMALIZED"
	from       :lt_merge_output                                                                       t_merge_output
	inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_tmp
	on  t_ta_tmp."CONFIG_ID"  = t_merge_output."CONFIG_ID"
	and t_ta_tmp."BATCH_ID"   = t_merge_output."BATCH_ID"
	and t_ta_tmp."DWID"       = t_merge_output."DWID"
	and t_ta_tmp."TA_COUNTER" = t_merge_output."TA_PARENT"
	and t_ta_tmp."TA_TYPE"    = :lv_hist_parent
	;

	/* Try to insert med_HISTO/ICDO3 code from dictionary match in TA_NORMALIZED column of med_CancerHistology extraction when one 
	   wasn't returned by advanced matching. In particular, only insert med_HISTO/ICDO3 code from dictionary if it is the 
	   only dictionary code the corresponding med_CancerHistology extraction can be paired with.
	*/
	
	-- all med_CancerHistology / med_HISTO/ICDO3 tuples for which no TA_NORMALIZED was assigned above
	-- (either due to no or multiple (ambiguous) codes returned by AM)
	
	lt_hist_dict =
		select
			t_hist."CONFIG_ID",
			t_hist."BATCH_ID",
			t_hist."DWID",
			t_hist."TA_PARENT",
			t_icdo."TA_NORMALIZED"
		from       "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_hist
		inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_icdo
		on  t_hist."CONFIG_ID"    = :iv_config_id
		and t_hist."BATCH_ID"     = :iv_ta_batch_id
		and t_icdo."CONFIG_ID" = :iv_config_id
		and t_icdo."BATCH_ID"  = :iv_ta_batch_id
		and t_hist."DWID"         = t_icdo."DWID"
		and ((t_hist."TA_TYPE" = :lv_ca_hist_rule) or (t_hist."TA_TYPE" = :lv_ca_icdo_rule))
		and t_icdo."TA_TYPE"   = :lv_hist_dict
		and t_hist."TA_TOKEN"     = t_icdo."TA_TOKEN"
		and t_hist."TA_OFFSET"    = t_icdo."TA_OFFSET"
		and t_hist."TA_NORMALIZED" is null
	;
	
	lt_ambig_hist_dict = 
		select
			"DWID",
			"TA_PARENT"
		from :lt_hist_dict
		group by
			"DWID",
			"TA_PARENT"
		having count(distinct "TA_NORMALIZED") > 1
	;
	
	update "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_temp
	set t_ta_temp."TA_NORMALIZED" = t_hist_dict."TA_NORMALIZED"
	from       :lt_hist_dict t_hist_dict
	inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_temp
	on  t_ta_temp."CONFIG_ID"  = :iv_config_id
	and t_ta_temp."BATCH_ID"   = :iv_ta_batch_id
	and t_ta_temp."DWID"       = t_hist_dict."DWID"
	and t_ta_temp."TA_COUNTER" = t_hist_dict."TA_PARENT"
	and t_ta_temp."TA_TYPE"    = :lv_hist_parent
	and t_ta_temp."TA_NORMALIZED" is null
	-- exclude ambiguous dictionary matches
	left outer join :lt_ambig_hist_dict t_ambig_hist_dict
	on  t_ambig_hist_dict."DWID"      = t_ta_temp."DWID"
	and t_ambig_hist_dict."TA_PARENT" = t_ta_temp."TA_COUNTER"
	where t_ambig_hist_dict."DWID" is null
	;
	
	-- all ambiguous med_CancerHistology entities (ambiguous AM matches or ambiguous dictionary matches)
	lt_ambig_hist_parent =
		select
			"DWID",
			"TA_PARENT"
		from :lt_ambig_hist_dict
		
		union
		
		select
			t_cand_tmp."DWID",
			t_ta_temp."TA_COUNTER" as "TA_PARENT"
		from       :lt_ambig_cand t_ambig_cand
		inner join :lt_cand_tmp   t_cand_tmp
		on t_cand_tmp."CandidateID" = t_ambig_cand."CandidateID"
		inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_temp
		on  t_ta_temp."CONFIG_ID"  = :iv_config_id
		and t_ta_temp."BATCH_ID"   = :iv_ta_batch_id
		and t_ta_temp."DWID"       = t_cand_tmp."DWID"
		and t_ta_temp."TA_COUNTER" = t_cand_tmp."TA_PARENT"
	;
	
	-- update TA_AMBIGUITY
	update "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_temp
	set t_ta_temp."TA_AMBIGUITY" = :lv_ambig
	from       :lt_ambig_hist_parent t_ambig_hist_parent
	inner join "hc.hph.plugins.textProcessing.pathology.postProcessing::Entities.TA_EXT" t_ta_temp
	on  t_ta_temp."CONFIG_ID"  = :iv_config_id
	and t_ta_temp."BATCH_ID"   = :iv_ta_batch_id
	and t_ta_temp."DWID"       = t_ambig_hist_parent."DWID"
	and t_ta_temp."TA_COUNTER" = t_ambig_hist_parent."TA_PARENT"
	and t_ta_temp."TA_TYPE"    = :lv_hist_parent
	and t_ta_temp."TA_NORMALIZED" is null
	;
	
end
;
