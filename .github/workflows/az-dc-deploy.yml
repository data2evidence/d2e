name: DockerCompose AzureDev Deploy
run-name: ${{ github.event.inputs.env }} ${{ github.event.inputs.repo_full_name }}

on:
  workflow_dispatch:
    inputs:
      repo_full_name:
        description: Select RepoName
        options:
          - alp-os/d2e
          - alp-os/d2e-dev-afreen
          - alp-os/d2e-dev-alicia
          - alp-os/d2e-dev-brandan
          - alp-os/d2e-dev-brian
          - alp-os/d2e-dev-hengxian
          - alp-os/d2e-dev-jerome
          - alp-os/d2e-dev-khairul
          - alp-os/d2e-dev-mwaiyee
          - alp-os/d2e-dev-nicholas
          - alp-os/d2e-dev-peter
          - alp-os/d2e-dev-ragavan
          - alp-os/d2e-dev-santan
          - alp-os/d2e-dev-satish
          - alp-os/d2e-dev-suwarno
        required: true
        type: choice
      env:
        default: alp-dev-sg-3
        description: Select the environment
        required: true
        type: environment
      force-cleanup-containers:
        description: Force cleanup all containers
        type: boolean
        default: false
      docker-tag-develop:
        description: tag:*:develop
        type: boolean
      docker-tag-textbox:
        description: tag:fromTextbox (precedence)
        type: string
        required: false
      dotenv-boolean:
        description: boolean:dotenv
        type: boolean
        default: true

env:
  DOCKER_TAG_NAME: ${{ github.event.inputs.docker-tag-textbox || 'develop' }}
  ENV_NAME: ${{ github.event.inputs.env }}
  ENV_TYPE: remote

concurrency:
  group: az-dc-deploy-${{ github.event.inputs.env }}
  cancel-in-progress: true

jobs:
  deploy:
    environment: ${{ github.event.inputs.env }}
    name: ${{ github.event.inputs.env }}
    runs-on: ["${{ github.event.inputs.env }}", self-hosted, Linux, X64]
    steps:
      - uses: actions/checkout@v4.1.1
        name: checkout d2e repo
        with:
          clean: false
          ref: ${{ env.DOCKER_TAG_NAME }}
          repository: ${{ github.event.inputs.repo_full_name }}
          token: ${{ secrets.CI_PAT }}

      - name: Force cleanup containers
        if: github.event.inputs.force-cleanup-containers
        continue-on-error: true
        run: docker rm -v -f $(docker ps -qa)

      - name: 1password ratelimit start
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        run: |
          ./internal/scripts/get-op-ratelimit.sh

      - name: Load secrets from 1password
        uses: 1password/load-secrets-action@v2
        id: op-load-secret
        with:
          export-env: true
        env:
          ENV__BASE_All__YML: op://${{ secrets.OP_VAULT_NAME }}/.env.base-all.yml/notesPlain # deprecate once 1password updated with flat yml
          ENV__BASE_REMOTE__YML: op://${{ secrets.OP_VAULT_NAME }}/.env.base-remote.yml/notesPlain # deprecate once 1password updated with flat yml
          ENV__NAME__YML: op://${{ secrets.OP_VAULT_NAME }}/.env.${{ env.ENV_NAME }}.yml/notesPlain
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          REGISTRY_USERNAME: "op://${{ secrets.OP_VAULT_NAME }}/az-alpCR/username"
          REGISTRY_PASSWORD: "op://${{ secrets.OP_VAULT_NAME }}/az-alpCR/password"

      - name: 1password ratelimit end
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        run: |
          ./internal/scripts/get-op-ratelimit.sh

      - name: Upload stats.yml artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: stats
          retention-days: 30
          path: |
            ${{ github.job }}*.yml

      - name: Generate dotenv
        env:
          CACHE_DIR: cache/op
          DOTENV_FILE: .env.${{ env.ENV_TYPE }}
          DOTENV_YML: .env.${{ env.ENV_NAME }}.yml
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          OP_VAULT_NAME: ${{ secrets.OP_VAULT_NAME }}
          OVERWRITE: true
        run: |
          ACTIONS_STEP_DEBUG=false
          if [ ${{ github.event.inputs.dotenv-boolean }} = true ]
          then
            # echo dot env yml files with env-vars from 1password
            echo "${ENV__BASE_All__YML}" > $CACHE_DIR/.env.base-all.yml # deprecate once 1password updated with flat yml
            echo "${ENV__BASE_REMOTE__YML}" > $CACHE_DIR/.env.base-remote.yml # deprecate once 1password updated with flat yml
            echo "${ENV__NAME__YML}" > $CACHE_DIR/.env.$ENV_NAME.yml # remove $CACHE_DIR/ once 1password updated with flat yml
          else
            # expect env yml on-disk from a previous deploy
            echo dotenv-boolean=false | tee -a $GITHUB_STEP_SUMMARY
          fi

          # cache: .env.base-all.yml .env.base-$ENV_TYPE.yml .env.$ENV_NAME.yml => .env.$ENV_NAME.yml
          yarn internal flatten:env # deprecate once 1password updated with flat yml

          # convert .env.${ENV_NAME}.yml to .env.${ENV_TYPE}
          yarn internal set:env

          # additional mask sensitive values
          internal/scripts/mask-env-gha.sh

          # action
          echo CADDY__ALP__PUBLIC_FQDN=$(yq '.CADDY__ALP__PUBLIC_FQDN' $DOTENV_YML) | tee -a $GITHUB_ENV | tee -a $GITHUB_STEP_SUMMARY

          cp $DOTENV_FILE ../$DOTENV_FILE-${GITHUB_RUN_ID}-$(date '+%Y%m%dT%H%M%S')

          [ "${{ github.event.inputs.docker-tag-develop }}" = true ] && DOCKER_TAG_NAME=develop
          UI_DOCKER_TAG_NAME=$DOCKER_TAG_NAME
          [ "${{ github.event.inputs.ui-docker-tag-develop }}" = true ] && UI_DOCKER_TAG_NAME=develop
          [ "${{ github.event.inputs.ui-docker-tag-textbox }}" != '' ] && UI_DOCKER_TAG_NAME=${{ github.event.inputs.ui-docker-tag-textbox }}

          echo DOCKER_TAG_NAME=$DOCKER_TAG_NAME | tee -a $DOTENV_FILE | tee -a $GITHUB_ENV | tee -a $GITHUB_STEP_SUMMARY
          echo UI_DOCKER_TAG_NAME=$UI_DOCKER_TAG_NAME | tee -a $DOTENV_FILE | tee -a $GITHUB_ENV | tee -a $GITHUB_STEP_SUMMARY
          echo HEAD_COMMIT_MESSAGE=$(git show -s --format=%s) | tee -a "$GITHUB_STEP_SUMMARY"
          echo GITHUB_SHA_SHORT=$(git rev-parse --short HEAD) | tee -a "$GITHUB_STEP_SUMMARY"

      - name: Login to ACR
        uses: docker/login-action@v3.1.0
        with:
          registry: alpcr.azurecr.io
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: Pull docker images
        uses: nick-fields/retry@v3
        with:
          timeout_seconds: 1800
          retry_wait_seconds: 60
          max_attempts: 10
          retry_on: any
          command: |
            # customize dc.yml
            yq -i '.services.alp-minerva-postgres.ports=["41190:5432"]' docker-compose.yml # expose PG port
            yarn remote:minerva pull

      - name: docker compose up
        env:
          GATEWAY_NAME: alp-minerva-gateway-1
        run: |
          echo CADDY__ALP__PUBLIC_FQDN=$CADDY__ALP__PUBLIC_FQDN

          # Run ALP services
          yarn remote:minerva up --remove-orphans --force-recreate --wait
          EXIT_CODE=$?

          if [ "$( docker container inspect -f '{{.State.Status}}' $GATEWAY_NAME )" = "running" ]; then
            echo open https://$CADDY__ALP__PUBLIC_FQDN/portal/index.html | tee -a $GITHUB_STEP_SUMMARY
            echo | tee -a $GITHUB_STEP_SUMMARY
          fi

          yarn base:minerva ps --format "{{.Names}} {{.Status}}" 2> /dev/null | grep ^alp | tee -a $GITHUB_STEP_SUMMARY
          echo | tee -a $GITHUB_STEP_SUMMARY

          if [ $EXIT_CODE != 0 ]; then
            echo "ERROR docker compose exit code $EXIT_CODE" | tee -a $GITHUB_STEP_SUMMARY
            exit $EXIT_CODE
          fi

      - name: Logs minerva
        if: success() || failure()
        run: |
          yarn logs:minerva:startup

      - name: Post cleanup
        if: always()
        run: |
          docker rm -f alp-caddy-certs-mgmt || true # Cleanup cert mgmt container if job aborted
